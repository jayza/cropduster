<html>
<head></head>
<body>
  <form action="" id="form">
    <input type="file" name="file" id="file">
    <input type="submit" value="Add" id="submit">
  </form>
  <canvas id="canvas" width="500" height="500"></canvas>
  <div id="previewCanvas" style="width:500px;height:500px;"></div>

  <script>
    let uploadedFile = document.getElementById('file');
    let form = document.getElementById('form');
    let submit = document.getElementById('submit');
    let c = document.getElementById('canvas');

    function ImageDrawer(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.reader = new FileReader();
      this.image = new Image();
      
      this.reader.onload = this.readerLoader.bind(this);
      this.image.onload = this.imageLoader.bind(this);

      this.canvas.addEventListener('redrawImage', this.redraw.bind(this), false);
    };

    ImageDrawer.prototype = {
      draw: function() {
        this.ctx.drawImage(this.image, 0, 0, 500, 500);
      },
      clear: function() {
        this.ctx.beginPath();
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.closePath();
      },
      redraw: function() {
        this.clear();
        this.draw();
      },
      load: function(file) {
        this.reader.readAsDataURL(file);
      },
      readerLoader: function() {
        let base64 = this.reader.result;
        this.image.src = base64;
      },
      imageLoader: function() {
        this.draw(this.image);
      }
    };

    function CanvasSelector(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.selectActive = null;
      this.anchorActive = null;

      this.originSelectX = null;
      this.originSelectY = null;

      this.currentSelectX = null;
      this.currentSelectY = null;

      this.selectWidth = null;
      this.selectHeight = null;
      
      this.lockCol = false;
      this.lockRow = false;

      this.selectedAnchorsHistory = [];

      this.anchorSize = 5;

      this.previewImage = null;

      this.anchors = [];
      this.anchorOpposites = [
        [{ row: 2, col: 2},{ row: 2, col: 1},{ row: 2, col: 0}],
        [{ row: 1, col: 1},{ row: 1, col: 0}],
        [{ row: 0, col: 2},{ row: 0, col: 1},{ row: 0, col: 0}]
      ];

      this.form = document.createElement('form');
      
      this.form.setAttribute('id', 'form-controls');
        let inputWidth = document.createElement('input');
            inputWidth.setAttribute('type', 'text');
            inputWidth.setAttribute('id', 'width');
            inputWidth.setAttribute('name', 'width');
        let inputHeight = document.createElement('input');
            inputHeight.setAttribute('type', 'text');
            inputHeight.setAttribute('id', 'height');
            inputHeight.setAttribute('name', 'height');

      this.form.appendChild(inputWidth);
      this.form.appendChild(inputHeight);

      document.body.insertBefore(this.form, this.canvas);
      
      //Events
      this.eventRedraw = new Event('redrawImage');
      
      canvas.addEventListener('mousedown', this.mousedownEvent.bind(this), false);
      canvas.addEventListener('mouseup', this.mouseupEvent.bind(this), false);
      canvas.addEventListener('mousemove', this.hoverEvent.bind(this), false);
      canvas.addEventListener('redrawImage', this.updateForm.bind(this), false);
      this.form.addEventListener('change',  this.formChange.bind(this), false);
    };

    CanvasSelector.prototype = {
      formChange: function(e) {
        let formValues = new FormData(this.form);

        this.selectWidth = parseFloat(formValues.get('width'));
        this.selectHeight = parseFloat(formValues.get('height'));

        this.draw();
      },
      updateForm: function(e) {
        document.getElementById('width').value = Math.abs(this.selectWidth);  
        document.getElementById('height').value = Math.abs(this.selectHeight);
      },
      countAnchorClicks: function(collider) {
        // Add clicked anchor to history array.
        this.selectedAnchorsHistory.unshift(collider.pos);
        
        // Only save 3 last actions in the history.
        if (this.selectedAnchorsHistory.length == 3) {
          this.selectedAnchorsHistory.pop();
        }
        
        let clicksInARow = 0;
        for (var i = 0; i < this.selectedAnchorsHistory.length; i++) {
          if (this.selectedAnchorsHistory[i].row == collider.pos.row && this.selectedAnchorsHistory[i].col == collider.pos.col) {
            clicksInARow++;
          }
          else {
            break;
          }
        };

        return clicksInARow;
      },
      mousedownEvent: function(e) {
        console.log('mousedown');
        let x = e.layerX;
        let y = e.layerY;

        // Check if we click on anchors.
        let collidingAnchor = this.collidingAnchors(x,y);
        if (collidingAnchor !== false && !this.selectActive) {
          this.anchorActive = true;
          
          // let countAnchorClicks = this.countAnchorClicks(collidingAnchor);

          // if (countAnchorClicks > 1) {
          //   if (countAnchorClicks == 2) {
          //     console.log('double click')
          //   }

          //   return;
          // }

          let anchorOpposite = this.getOppositeAnchor(collidingAnchor);      
          if (typeof anchorOpposite == 'object') {
            if (collidingAnchor.pos.row == 1) {
              this.lockCol = true;
              if (collidingAnchor.pos.col == 0) {
                this.originSelectX = this.anchors[0][2].x;
                this.originSelectY = this.anchors[0][2].y;
              }
              else {
                this.originSelectX = this.anchors[0][0].x;
                this.originSelectY = this.anchors[0][0].y;
              }
            } 
            else if (collidingAnchor.pos.row != 1 && collidingAnchor.pos.col == 1) {
              this.lockRow = true;
              if (collidingAnchor.pos.row == 0) {
                this.originSelectX = this.anchors[2][0].x;
                this.originSelectY = this.anchors[2][0].y;
              }
              else {
                this.originSelectX = this.anchors[0][0].x;
                this.originSelectY = this.anchors[0][0].y;
              }
            }
            else {
              this.originSelectX = anchorOpposite.x;
              this.originSelectY = anchorOpposite.y;
            }

            this.selectActive = true;
            this.selectMove(e);
          }

          return;
        }
        
        // Otherwise run default click option.
        this.selectClick(e);
      },
      mouseupEvent: function(e) {
        // Reset anchor active after dropping handle.
        if (this.anchorActive != null) {
          this.anchorActive = null;
        }

        if (this.selectActive) {
          this.selectActive = null;
          this.anchorActive = null;

          // Reset so origin is in top left anchor.
          this.resetOrigin();

          this.draw();
        }
        else {
          this.resetOrigin();

          // Output preview image of selected area.
          this.canvas.dispatchEvent(this.eventRedraw);
          this.previewImage = this.ctx.getImageData(this.originSelectX, this.originSelectY, this.selectWidth, this.selectHeight);
          let eventImagePreview = new CustomEvent('imagePreview', { detail: this.previewImage });
          window.dispatchEvent(eventImagePreview);

          this.draw();
        }
      },
      hoverEvent: function(e) {
        if (this.selectActive) {
          this.selectMove(e);
          return;
        }

        this.hoverCursor(e);
      },
      hoverCursor: function(e) {
        let x = e.layerX;
        let y = e.layerY;

        // Resize
        if (this.anchorActive != null) {
          this.resize(e);
          return;
        }

        // Check if we hover on anchors.
        let collidingAnchor = this.collidingAnchors(x,y);
        if (collidingAnchor !== false) {
          this.canvas.style.cursor = collidingAnchor.anchor.cursor;
          return;
        }

        // Otherwise run default hover option.
        this.canvas.style.cursor = "auto";
        this.selectMove(e);
      },
      selectClick: function(e) {
        // If we're currently selecting a boundary.
        if (this.selectActive) {
          this.selectActive = false;
          this.addAnchors();
          return;
        }

        // Clear previous boundaries.
        this.canvas.dispatchEvent(this.eventRedraw);

        this.selectActive = true;

        this.originSelectX = e.layerX,
        this.originSelectY = e.layerY;
      },
      selectMove: function(e) {
        if (!this.selectActive)
          return;
        
        this.currentSelectX = e.layerX;
        this.currentSelectY = e.layerY;

        this.selectWidth = (!this.lockRow) ? this.currentSelectX - this.originSelectX : this.selectWidth;
        this.selectHeight = (!this.lockCol) ? this.currentSelectY - this.originSelectY : this.selectHeight;
        
        // Redraw.
        this.draw();
      },
      // Resize rectangle.
      resize: function(e) {
        let originalAnchor = this.anchorActive;
      },
      // Draw rectangle.
      draw: function() {
        this.canvas.dispatchEvent(this.eventRedraw);
        
        // Add transparency around the selected area.
        let anchorMatrix = this.anchorMatrix();
        if (anchorMatrix.length > 0) {
          this.ctx.save();
          this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
          this.ctx.fillRect(0,0, anchorMatrix[0][0].x, this.canvas.height);
          this.ctx.fillRect(anchorMatrix[0][2].x, 0, Math.abs(this.canvas.width - this.selectWidth), this.canvas.height);
          this.ctx.fillRect(anchorMatrix[0][0].x, 0, Math.abs(this.selectWidth), anchorMatrix[0][0].y);
          this.ctx.fillRect(anchorMatrix[2][0].x, anchorMatrix[2][0].y, Math.abs(this.selectWidth), Math.abs(this.canvas.height - anchorMatrix[2][0].y));
          this.ctx.restore();
        }
        
        // Draw the selected area.
        this.ctx.rect(
          this.originSelectX, 
          this.originSelectY, 
          this.selectWidth,
          this.selectHeight
        );

        this.ctx.stroke();

        if (!this.selectActive) {
          this.addAnchors();
        }
      },
      resetOrigin: function() {
        let anchorMatrix = this.anchorMatrix();

        this.lockCol = false;
        this.lockRow = false;

        this.originSelectX = anchorMatrix[0][0].x;
        this.originSelectY = anchorMatrix[0][0].y;
        this.selectWidth = Math.abs(this.selectWidth);
        this.selectHeight = Math.abs(this.selectHeight);
      },
      // Check if x,y coordinates matches with anchors.
      collidingAnchors: function(x, y) {
        let collision = false;
        this.anchors.forEach((anchorRow, row) => {
          anchorRow.forEach((anchor, pos) => {
            if (
              x >= (anchor.x - 5) && 
              x <= (anchor.x + 10) &&
              y >= (anchor.y - 5) &&
              y <= (anchor.y + 10)
            ) {
              collision = {
                anchor: anchor,
                pos: {
                  row: row,
                  col: pos
                }
              };
            }
          });
        });

        return collision;
      },
      // Get the anchor that is oppposite across the rectangle.
      getOppositeAnchor: function(collision) {
        let anchorOpposite = this.anchorOpposites[collision.pos.row][collision.pos.col];
        return this.anchors[anchorOpposite.row][anchorOpposite.col];
      },
      anchorMatrix: function() {
        let anchors = [
          {x: this.originSelectX, y: this.originSelectY}, //origin
          {x: this.originSelectX + this.selectWidth, y: this.originSelectY + this.selectHeight}, //opposite origin
          {x: this.originSelectX + this.selectWidth, y: this.originSelectY}, //corner 1
          {x: this.originSelectX, y: this.originSelectY + this.selectHeight}, //corner 2
          {x: (this.selectWidth / 2) + this.originSelectX, y: this.originSelectY}, //horizontal middle 1
          {x: (this.selectWidth / 2) + this.originSelectX, y: this.originSelectY + this.selectHeight}, //horizontal middle 2
          {x: this.originSelectX, y: (this.selectHeight / 2) + this.originSelectY}, //vertical middle 1
          {x: this.originSelectX + this.selectWidth, y: (this.selectHeight / 2) + this.originSelectY} // vertical middle 2
        ];

        // Extract anchor positions from array.
        let topLeft = anchors.reduce((acc, val, i) => (val.x <= acc.x && val.y <= acc.y) ? val : acc, anchors[0]);
        let topRight = anchors.reduce((acc, val, i) => (val.x >= acc.x && val.y <= acc.y) ? val : acc, anchors[0]);
        let bottomRight = anchors.reduce((acc, val, i) => (val.x >= acc.x && val.y >= acc.y) ? val : acc, anchors[0]);
        let bottomLeft = anchors.reduce((acc, val, i) => (val.x <= acc.x && val.y >= acc.y) ? val : acc, anchors[0]);
        let topMiddle = anchors.filter((val) => (val.x == ((topRight.x + topLeft.x) / 2) && val.y == topLeft.y) ? val : null).pop();
        let bottomMiddle = anchors.filter((val) => (val.x == ((bottomRight.x + bottomLeft.x) / 2) && val.y == bottomLeft.y) ? val : null).pop();
        let rightMiddle = anchors.filter((val) => (val.x == topRight.x && val.y == (bottomRight.y + topRight.y) / 2) ? val : null).pop();
        let leftMiddle = anchors.filter((val) => (val.x == topLeft.x && val.y == (bottomRight.y + topRight.y) / 2) ? val : null).pop();
        
        // Build a matrix of anchors.
        return [
          [topLeft,topMiddle,topRight],
          [leftMiddle,rightMiddle],
          [bottomLeft,bottomMiddle,bottomRight]    
        ];
      },
      // Add all anchor handles.
      addAnchors: function() {
        this.anchors = this.anchorMatrix();

        let cursors = [
          "nwse-resize",
          "row-resize",
          "nesw-resize",
          "col-resize",
          "col-resize",
          "nesw-resize",
          "row-resize",
          "nwse-resize"
        ];

        this.anchors.forEach((anchorRow, row) => {
          anchorRow.forEach((anchor, col) => {
            direction = cursors.shift();
            this.anchors[row][col].cursor = direction;
            this.ctx.fillRect(anchor.x - (this.anchorSize / 2), anchor.y - (this.anchorSize / 2), this.anchorSize, this.anchorSize);
          });
        });
      }
    };

    let imageDrawer = new ImageDrawer(c);
    let canvasSelector = new CanvasSelector(c);

    window.addEventListener('imagePreview', function(e) {
      let img = imagedata_to_image(e.detail);

      let preview = document.getElementById('previewCanvas');
      let uri = "url('"+img+"')";
          preview.style.backgroundImage = uri;
    });

    function imagedata_to_image(imagedata) {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      canvas.width = imagedata.width;
      canvas.height = imagedata.height;
      ctx.putImageData(imagedata, 0, 0);

      return canvas.toDataURL();
  }

    submit.addEventListener('click', function(e) {
      e.preventDefault();
      
      let file = uploadedFile.files[0];

      imageDrawer.load(file);          
    });

  </script>
</body>
</html>